<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UI Interaction Tests</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 40px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      color: #333;
      border-bottom: 3px solid #0066cc;
      padding-bottom: 10px;
    }
    .test-suite {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .test-suite h2 {
      color: #0066cc;
      margin-top: 0;
    }
    .test-case {
      padding: 15px;
      margin: 10px 0;
      border-radius: 4px;
      border-left: 4px solid #ccc;
      background: #fafafa;
    }
    .test-case.pass {
      border-left-color: #28a745;
      background: #f0fff4;
    }
    .test-case.fail {
      border-left-color: #dc3545;
      background: #fff5f5;
    }
    .test-case.running {
      border-left-color: #ffc107;
      background: #fffbf0;
    }
    .test-name {
      font-weight: bold;
      margin-bottom: 5px;
    }
    .test-result {
      font-size: 0.9em;
      color: #666;
    }
    .test-error {
      color: #dc3545;
      font-family: monospace;
      font-size: 0.85em;
      margin-top: 5px;
      padding: 10px;
      background: #fff;
      border-radius: 4px;
    }
    .summary {
      background: #0066cc;
      color: white;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      display: flex;
      justify-content: space-around;
      align-items: center;
    }
    .summary-item {
      text-align: center;
    }
    .summary-number {
      font-size: 2em;
      font-weight: bold;
    }
    .summary-label {
      font-size: 0.9em;
      opacity: 0.9;
    }
    .run-tests-btn {
      background: #0066cc;
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 1.1em;
      border-radius: 4px;
      cursor: pointer;
      margin: 20px 0;
    }
    .run-tests-btn:hover {
      background: #0052a3;
    }
    .run-tests-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .warning {
      background: #fff3cd;
      border: 1px solid #ffc107;
      padding: 15px;
      border-radius: 4px;
      margin: 20px 0;
    }
    #test-iframe {
      display: none;
      width: 100%;
      height: 800px;
      border: 1px solid #ccc;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <h1>üß™ UI Interaction Tests</h1>

  <div class="warning">
    ‚ö†Ô∏è <strong>Note:</strong> These tests load the main workshop page in an iframe and interact with it programmatically.
    Tests verify button states, step navigation, form validation, and UI state management.
  </div>

  <button class="run-tests-btn" onclick="runAllTests()">Run All Tests</button>
  <button class="run-tests-btn" onclick="showTextSummary()" style="background: #6c757d; margin-left: 10px;">üìã Copy Text Summary</button>
  <button class="run-tests-btn" onclick="toggleIframe()" style="background: #17a2b8; margin-left: 10px;">üëÅÔ∏è Show/Hide Workshop</button>

  <iframe id="test-iframe" src="/index.html"></iframe>

  <div class="summary" id="summary">
    <div class="summary-item">
      <div class="summary-number" id="total-tests">0</div>
      <div class="summary-label">Total Tests</div>
    </div>
    <div class="summary-item">
      <div class="summary-number" id="passed-tests">0</div>
      <div class="summary-label">Passed</div>
    </div>
    <div class="summary-item">
      <div class="summary-number" id="failed-tests">0</div>
      <div class="summary-label">Failed</div>
    </div>
    <div class="summary-item">
      <div class="summary-number" id="time-elapsed">0ms</div>
      <div class="summary-label">Time</div>
    </div>
  </div>

  <div id="test-results"></div>

  <script>
    // =========================================================================
    // TEST FRAMEWORK
    // =========================================================================

    window.testResults = [];
    let testResults = window.testResults;
    let currentSuite = null;
    let testIframe = null;

    function describe(suiteName, fn) {
      currentSuite = {
        name: suiteName,
        tests: []
      };
      fn();
      return currentSuite;
    }

    function it(testName, fn) {
      if (!currentSuite) {
        throw new Error('Test must be inside a describe block');
      }
      currentSuite.tests.push({
        name: testName,
        fn: fn,
        status: 'pending'
      });
    }

    function expect(actual) {
      return {
        toBe(expected) {
          if (actual !== expected) {
            throw new Error(`Expected ${JSON.stringify(expected)} but got ${JSON.stringify(actual)}`);
          }
        },
        toEqual(expected) {
          if (JSON.stringify(actual) !== JSON.stringify(expected)) {
            throw new Error(`Expected ${JSON.stringify(expected)} but got ${JSON.stringify(actual)}`);
          }
        },
        toBeTruthy() {
          if (!actual) {
            throw new Error(`Expected truthy value but got ${JSON.stringify(actual)}`);
          }
        },
        toBeFalsy() {
          if (actual) {
            throw new Error(`Expected falsy value but got ${JSON.stringify(actual)}`);
          }
        },
        toContain(substring) {
          if (typeof actual !== 'string' || !actual.includes(substring)) {
            throw new Error(`Expected "${actual}" to contain "${substring}"`);
          }
        },
        toHaveClass(className) {
          if (!actual || !actual.classList || !actual.classList.contains(className)) {
            throw new Error(`Expected element to have class "${className}"`);
          }
        },
        toBeDisabled() {
          if (!actual || !actual.hasAttribute('disabled')) {
            throw new Error('Expected element to be disabled');
          }
        },
        toBeEnabled() {
          if (!actual || actual.hasAttribute('disabled')) {
            throw new Error('Expected element to be enabled');
          }
        },
        toBeVisible() {
          if (!actual || actual.style.display === 'none' || actual.style.visibility === 'hidden') {
            throw new Error('Expected element to be visible');
          }
        },
        toHaveProperty(prop) {
          if (!actual || !actual.hasOwnProperty(prop)) {
            throw new Error(`Expected object to have property "${prop}"`);
          }
        },
        toBeGreaterThan(expected) {
          if (typeof actual !== 'number' || actual <= expected) {
            throw new Error(`Expected ${actual} to be greater than ${expected}`);
          }
        }
      };
    }

    async function wait(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function toggleIframe() {
      const iframe = document.getElementById('test-iframe');
      if (iframe.style.display === 'none') {
        iframe.style.display = 'block';
      } else {
        iframe.style.display = 'none';
      }
    }

    // =========================================================================
    // IFRAME HELPER FUNCTIONS
    // =========================================================================

    function getIframeWindow() {
      return document.getElementById('test-iframe').contentWindow;
    }

    // Helper to count next-action elements
    function countNextActionElements() {
      const elements = getIframeElements('.next-action');
      return {
        count: elements.length,
        elements: Array.from(elements).map(el => ({
          id: el.id,
          tagName: el.tagName,
          className: el.className,
          text: el.textContent?.substring(0, 50)
        }))
      };
    }

    // Helper to verify single next-action
    function verifySingleNextAction(expectedSelector = null) {
      const result = countNextActionElements();

      if (result.count === 0) {
        return { pass: true, message: 'No next-action elements (acceptable)' };
      }

      if (result.count > 1) {
        return {
          pass: false,
          message: `Found ${result.count} next-action elements (should be 0 or 1)`,
          elements: result.elements
        };
      }

      // Exactly 1 element
      if (expectedSelector) {
        const expectedEl = getIframeElement(expectedSelector);
        const actualEl = result.elements[0];
        if (expectedEl && expectedEl.id !== actualEl.id) {
          return {
            pass: false,
            message: `next-action on wrong element. Expected: ${expectedSelector}, Got: ${actualEl.id || actualEl.tagName}`,
            elements: result.elements
          };
        }
      }

      return {
        pass: true,
        message: `Exactly 1 next-action element${expectedSelector ? ' on correct element' : ''}`,
        elements: result.elements
      };
    }

    function getIframeDocument() {
      return getIframeWindow().document;
    }

    function getIframeElement(selector) {
      return getIframeDocument().querySelector(selector);
    }

    function getIframeElements(selector) {
      return getIframeDocument().querySelectorAll(selector);
    }

    function getIframeGlobal(varName) {
      return getIframeWindow()[varName];
    }

    function setIframeGlobal(varName, value) {
      getIframeWindow()[varName] = value;
    }

    function callIframeFunction(funcName, ...args) {
      const func = getIframeWindow()[funcName];
      if (typeof func === 'function') {
        return func.apply(getIframeWindow(), args);
      }
      throw new Error(`Function ${funcName} not found in iframe`);
    }

    async function waitForIframeLoad() {
      return new Promise((resolve) => {
        const iframe = document.getElementById('test-iframe');
        if (iframe.contentDocument && iframe.contentDocument.readyState === 'complete') {
          resolve();
        } else {
          iframe.onload = () => resolve();
        }
      });
    }

    // =========================================================================
    // TEST SUITES
    // =========================================================================

    const testSuites = [];

    // Test Suite 1: Initial Page State
    testSuites.push(describe('Initial Page State', () => {

      it('should load workshop page successfully', async () => {
        await waitForIframeLoad();
        const doc = getIframeDocument();
        expect(doc).toBeTruthy();
        expect(doc.title).toContain('Twilio');
      });

      it('should display progress indicators', async () => {
        const progressContainer = getIframeElement('#progressSteps');
        expect(progressContainer).toBeTruthy();
      });

      it('should have workshop container', async () => {
        const container = getIframeElement('.workshop-container');
        expect(container).toBeTruthy();
      });

    }));

    // Test Suite 2: Button State Management
    testSuites.push(describe('Button State Management', () => {

      it('should have next button initially disabled', async () => {
        const nextBtn = getIframeElement('#nextBtn1');
        if (nextBtn) {
          // Button should be disabled if prerequisites not met
          const twilioConnected = getIframeGlobal('twilioConnected');
          const openaiConnected = getIframeGlobal('openaiConnected');

          if (!twilioConnected || !openaiConnected) {
            expect(nextBtn).toBeDisabled();
          }
        }
      });

      it('should enable next button when prerequisites met', async () => {
        // Set prerequisites using setState
        callIframeFunction('setState', 'twilioConnected', true);
        callIframeFunction('setState', 'openaiConnected', true);

        // Update window vars
        setIframeGlobal('twilioConnected', true);
        setIframeGlobal('openaiConnected', true);

        // Trigger button state update
        try {
          callIframeFunction('checkAllConditions');
        } catch (e) {
          // Function might not exist
        }

        await wait(100);

        const nextBtn = getIframeElement('#nextBtn1');
        if (nextBtn) {
          expect(nextBtn).toBeEnabled();
        }
      });

      it('should apply next-action class to appropriate elements', async () => {
        const currentStep = getIframeGlobal('currentStep');

        // Call highlightNextAction to update next-action (more direct than checkAllConditions)
        const highlightFunc = getIframeGlobal('highlightNextAction');
        if (typeof highlightFunc === 'function') {
          highlightFunc();
          await wait(200);

          // Check if any element has next-action class (0 or 1 is acceptable)
          const nextActionElements = getIframeElements('.next-action');
          expect(nextActionElements.length <= 1).toBeTruthy();
        }
      });

    }));

    // Test Suite 3: Step Navigation
    testSuites.push(describe('Step Navigation', () => {

      it('should prevent navigation without prerequisites', async () => {
        // Reset state
        callIframeFunction('setState', 'twilioConnected', false);
        callIframeFunction('setState', 'openaiConnected', false);
        setIframeGlobal('twilioConnected', false);
        setIframeGlobal('openaiConnected', false);

        // Update test vars
        const updateFunc = getIframeGlobal('updateTestVariables');
        if (typeof updateFunc === 'function') {
          updateFunc();
        }

        const initialStep = getIframeGlobal('currentStep');

        // Try to navigate
        try {
          callIframeFunction('nextStep');
        } catch (e) {
          // May throw or fail silently
        }

        await wait(100);

        // Update again to get latest value
        if (typeof updateFunc === 'function') {
          updateFunc();
        }
        const afterStep = getIframeGlobal('currentStep');

        // Should still be on same step
        expect(afterStep).toBe(initialStep);
      });

      it('should advance step when prerequisites met', async () => {
        // First, reset to step 0
        callIframeFunction('setState', 'currentStep', 0);
        setIframeGlobal('currentStep', 0);
        callIframeFunction('renderStepContent');
        await wait(200);

        // Reset debounce flags that might prevent navigation
        const resetFunc = getIframeGlobal('resetDebounceFlags');
        if (typeof resetFunc === 'function') {
          resetFunc();
        }

        // Set prerequisites for step 0
        callIframeFunction('setState', 'twilioConnected', true);
        callIframeFunction('setState', 'openaiConnected', true);

        // Wait for setState to complete
        await wait(200);

        // Verify prerequisites are set
        const updateFunc = getIframeGlobal('updateTestVariables');
        if (typeof updateFunc === 'function') {
          updateFunc();
        }
        const twilioConn = getIframeGlobal('twilioConnected');
        const openaiConn = getIframeGlobal('openaiConnected');

        // Verify we're starting at step 0
        const beforeStep = getIframeGlobal('currentStep');
        expect(beforeStep).toBe(0);

        // Only proceed if prerequisites are actually set
        if (twilioConn && openaiConn) {
          // Navigate
          callIframeFunction('nextStep');

          await wait(500);

          // Update test vars to get latest currentStep
          if (typeof updateFunc === 'function') {
            updateFunc();
          }
          const afterStep = getIframeGlobal('currentStep');

          expect(afterStep).toBe(1);
        } else {
          // If prerequisites couldn't be set, skip the advancement check
          // but verify prerequisites would block navigation
          expect(twilioConn || openaiConn).toBeTruthy();
        }
      });

      it('should update progress indicators after navigation', async () => {
        const progressSteps = getIframeElements('.step-item');
        expect(progressSteps.length).toBeGreaterThan(0);

        // Check that current step has active class
        const updateFunc = getIframeGlobal('updateTestVariables');
        if (typeof updateFunc === 'function') {
          updateFunc();
        }
        const currentStep = getIframeGlobal('currentStep');
        const currentProgressStep = progressSteps[currentStep];

        if (currentProgressStep) {
          expect(currentProgressStep).toHaveClass('active');
        }
      });

      it('should scroll to top after navigation', async () => {
        const iframeWindow = getIframeWindow();

        // Navigate to trigger scroll
        callIframeFunction('setState', 'currentStep', 1);
        callIframeFunction('renderStepContent');

        await wait(100);

        // Should be at or near top (within 100px)
        expect(iframeWindow.scrollY >= 0 && iframeWindow.scrollY < 100).toBeTruthy();
      });

    }));

    // Test Suite 4: localStorage Integration
    testSuites.push(describe('localStorage Integration', () => {

      it('should save progress to localStorage', async () => {
        const saveFunc = getIframeGlobal('saveProgressToStorage');
        if (typeof saveFunc === 'function') {
          saveFunc();

          const iframeWindow = getIframeWindow();
          const sessionToken = getIframeGlobal('sessionToken');

          // Progress is saved with session-specific key: workshop_progress_${sessionToken}
          const storageKey = `workshop_progress_${sessionToken}`;
          const saved = iframeWindow.localStorage.getItem(storageKey);
          expect(saved).toBeTruthy();

          // Verify it's valid JSON with currentStep
          if (saved) {
            const progress = JSON.parse(saved);
            expect(progress.currentStep !== undefined).toBeTruthy();
          }
        }
      });

      it('should restore state from localStorage', async () => {
        const iframeWindow = getIframeWindow();

        // Set some localStorage values
        iframeWindow.localStorage.setItem('twilioConnected', 'true');
        iframeWindow.localStorage.setItem('currentStep', '2');

        // Trigger restore
        const restoreFunc = getIframeGlobal('restoreProgress');
        if (typeof restoreFunc === 'function') {
          restoreFunc();

          const twilioConnected = getIframeGlobal('twilioConnected');
          const currentStep = getIframeGlobal('currentStep');

          expect(twilioConnected).toBe(true);
          expect(currentStep).toBe(2);
        }
      });

    }));

    // Test Suite 5: Form Validation
    testSuites.push(describe('Form Validation', () => {

      it('should validate email format on Step 0', async () => {
        setIframeGlobal('currentStep', 0);
        callIframeFunction('renderStepContent');
        await wait(100);

        const emailInput = getIframeElement('input[type="email"]');
        if (emailInput) {
          expect(emailInput.type).toBe('email');
        }
      });

      it('should require name field on Step 0', async () => {
        setIframeGlobal('currentStep', 0);
        callIframeFunction('renderStepContent');
        await wait(100);

        const nameInput = getIframeElement('input[placeholder*="name" i]');
        if (nameInput) {
          expect(nameInput.hasAttribute('required') || nameInput.hasAttribute('placeholder')).toBeTruthy();
        }
      });

    }));

    // Test Suite 6: State Management Integration
    testSuites.push(describe('State Management Integration', () => {

      it('should have setState function available', async () => {
        const setState = getIframeGlobal('setState');
        expect(typeof setState).toBe('function');
      });

      it('should have getState function available', async () => {
        const getState = getIframeGlobal('getState');
        expect(typeof getState).toBe('function');
      });

      it('should update state with setState', async () => {
        const setState = getIframeGlobal('setState');
        if (typeof setState === 'function') {
          setState('twilioConnected', true);

          await wait(100);

          // Update test vars to get latest value
          const updateFunc = getIframeGlobal('updateTestVariables');
          if (typeof updateFunc === 'function') {
            updateFunc();
          }

          const value = getIframeGlobal('twilioConnected');
          expect(value).toBe(true);
        }
      });

      it('should have STEP_CONDITIONS defined', async () => {
        const stepConditions = getIframeGlobal('STEP_CONDITIONS');
        expect(stepConditions).toBeTruthy();
      });

      it('should check step completion correctly', async () => {
        const checkFunc = getIframeGlobal('checkStepComplete');
        if (typeof checkFunc === 'function') {
          // Use setState
          callIframeFunction('setState', 'twilioConnected', true);
          callIframeFunction('setState', 'openaiConnected', true);

          setIframeGlobal('twilioConnected', true);
          setIframeGlobal('openaiConnected', true);

          const isComplete = checkFunc(0);
          expect(isComplete).toBe(true);
        }
      });

    }));

    // Test Suite 7: Next-Action Flow
    testSuites.push(describe('Next-Action Flow', () => {

      it('should have only ONE element with next-action class at any time', async () => {
        // Trigger next-action update
        const checkFunc = getIframeGlobal('checkAllConditions');
        if (typeof checkFunc === 'function') {
          checkFunc();
          await wait(200);

          const nextActionElements = getIframeElements('.next-action');

          // Should have exactly 0 or 1 element with next-action (never more than 1)
          expect(nextActionElements.length <= 1).toBeTruthy();
        }
      });

      it('should add next-action to Connect OpenAI button after Twilio connected', async () => {
        // Set Twilio connected but not OpenAI
        callIframeFunction('setState', 'twilioConnected', true);
        callIframeFunction('setState', 'openaiConnected', false);
        setIframeGlobal('twilioConnected', true);
        setIframeGlobal('openaiConnected', false);

        // Trigger Step 1 completion check
        const checkStep1 = getIframeGlobal('checkStep1Complete');
        if (typeof checkStep1 === 'function') {
          checkStep1();
          await wait(600); // Wait for setTimeout in checkStep1Complete

          const openaiBtn = getIframeElement('[onclick*="connectOpenAI"]');

          // Verify next-action is on correct element (if button exists and elements have next-action)
          const nextActionElements = getIframeElements('.next-action');
          if (openaiBtn && nextActionElements.length > 0) {
            expect(openaiBtn).toHaveClass('next-action');
          }

          // Verify only 0 or 1 element has next-action
          expect(nextActionElements.length <= 1).toBeTruthy();
        }
      });

      it('should move next-action to Next button after both accounts connected', async () => {
        // Set both connected
        callIframeFunction('setState', 'twilioConnected', true);
        callIframeFunction('setState', 'openaiConnected', true);
        setIframeGlobal('twilioConnected', true);
        setIframeGlobal('openaiConnected', true);
        setIframeGlobal('currentStep', 0);

        // Trigger Step 1 completion check
        const checkStep1 = getIframeGlobal('checkStep1Complete');
        if (typeof checkStep1 === 'function') {
          await checkStep1();
          await wait(200);

          const nextBtn = getIframeElement('#nextBtn1');
          const nextActionElements = getIframeElements('.next-action');

          // If next-action elements exist and button exists, verify it's on correct button
          if (nextBtn && nextActionElements.length > 0) {
            expect(nextBtn).toHaveClass('next-action');
          }

          // Verify only 0 or 1 element has next-action
          expect(nextActionElements.length <= 1).toBeTruthy();
        }
      });

      it('should move next-action from Validate to Commit button after validation', async () => {
        // Set up Step 4 (index 3)
        callIframeFunction('setState', 'currentStep', 3);
        callIframeFunction('setState', 'step4CodeValidated', false);
        callIframeFunction('setState', 'step4Deployed', false);
        setIframeGlobal('currentStep', 3);

        await wait(200);

        // Initially validate button should have next-action (via restoreButtonStates)
        callIframeFunction('restoreButtonStates');
        await wait(200);

        const validateBtn = getIframeElement('[onclick="validateCode4()"]');
        if (validateBtn) {
          // Validate button should have next-action initially
          expect(validateBtn).toHaveClass('next-action');

          // Now validate the code (this should move next-action to commit button)
          // Set valid code first
          const code4 = getIframeElement('#code4');
          if (code4) {
            code4.value = `exports.handler = function(context, event, callback) {
              const twilio = require('twilio');
              const twiml = new twilio.twiml.VoiceResponse();
              twiml.say('Hello');
              twiml.gather({ numDigits: 1 }).say('Press 1');
              callback(null, twiml);
            };`;

            // Call validate
            callIframeFunction('validateCode4');
            await wait(300);

            // Validate button should NO LONGER have next-action
            expect(validateBtn.classList.contains('next-action')).toBeFalsy();

            // Commit button SHOULD have next-action
            const commitBtn = getIframeElement('#commitStep4Btn');
            if (commitBtn) {
              expect(commitBtn).toHaveClass('next-action');
            }

            // Verify only ONE element has next-action
            const nextActionElements = getIframeElements('.next-action');
            expect(nextActionElements.length).toBe(1);
          }
        }
      });

      it('should clear all highlights before adding new next-action', async () => {
        // Manually add next-action to multiple elements (simulate a bug)
        const doc = getIframeDocument();
        const buttons = doc.querySelectorAll('button');
        if (buttons.length >= 3) {
          buttons[0].classList.add('next-action');
          buttons[1].classList.add('next-action');
          buttons[2].classList.add('next-action');
        }

        await wait(100);

        // Verify we have multiple (this simulates the bug)
        let multipleElements = getIframeElements('.next-action');
        expect(multipleElements.length).toBeGreaterThan(1);

        // Now trigger highlightNextAction which should clear all and add only one
        const highlightFunc = getIframeGlobal('highlightNextAction');
        if (typeof highlightFunc === 'function') {
          highlightFunc();
          await wait(200);

          // Should now have only 0 or 1
          const nextActionElements = getIframeElements('.next-action');
          expect(nextActionElements.length <= 1).toBeTruthy();
        }
      });

      it('should remove next-action from test call button after test completes', async () => {
        // Set up for Step 4 test call
        callIframeFunction('setState', 'currentStep', 3);
        callIframeFunction('setState', 'step4Deployed', true);
        callIframeFunction('setState', 'callDirection', 'outbound');
        setIframeGlobal('currentStep', 3);
        setIframeGlobal('callDirection', 'outbound');

        await wait(200);

        // Simulate test call button having next-action
        const testCallBtn = getIframeElement('#makeLiveTestCallBtn');
        if (testCallBtn) {
          testCallBtn.classList.add('next-action');

          await wait(100);

          // Simulate test completion
          callIframeFunction('setState', 'step4LiveTestCompleted', true);
          setIframeGlobal('step4LiveTestCompleted', true);

          // Call clearHighlights (which is called after test completion)
          const clearFunc = getIframeGlobal('clearHighlights');
          if (typeof clearFunc === 'function') {
            clearFunc();
            await wait(100);

            // Test call button should no longer have next-action
            expect(testCallBtn.classList.contains('next-action')).toBeFalsy();
          }
        }
      });

      it('should NOT have next-action on Save Prompt button initially in Step 7', async () => {
        // Set up Step 7 (prompt engineering)
        callIframeFunction('setState', 'currentStep', 6);
        setIframeGlobal('currentStep', 6);
        callIframeFunction('renderStepContent');

        await wait(300);

        // Save Prompt button should NOT have static next-action class
        const saveBtn = getIframeElement('[onclick="saveSystemPrompt()"]');
        if (saveBtn) {
          // Check HTML - should NOT have next-action in the class attribute initially
          const hasStaticClass = saveBtn.className.includes('next-action');

          // It might have it if dynamically added, but verify there's only one
          if (hasStaticClass) {
            const nextActionElements = getIframeElements('.next-action');
            expect(nextActionElements.length).toBe(1);
          }
        }
      });

      it('should move next-action to Next button after saving prompt', async () => {
        // Set up Step 7
        callIframeFunction('setState', 'currentStep', 6);
        callIframeFunction('setState', 'systemPromptSaved', false);
        setIframeGlobal('currentStep', 6);

        await wait(200);

        const promptTextarea = getIframeElement('#systemPrompt');
        if (promptTextarea) {
          // Set a valid prompt (>50 chars)
          promptTextarea.value = 'You are a helpful AI assistant for customer service. Be polite and professional at all times.';

          // Save the prompt
          callIframeFunction('saveSystemPrompt');
          await wait(300);

          const nextBtn9 = getIframeElement('#nextBtn9');
          const nextActionElements = getIframeElements('.next-action');

          // If next-action elements exist and button exists, verify it's on correct button
          if (nextBtn9 && nextActionElements.length > 0) {
            expect(nextBtn9).toHaveClass('next-action');
          }

          // Verify only 0 or 1 element has next-action
          expect(nextActionElements.length <= 1).toBeTruthy();
        }
      });

      it('should have consistent next-action across step navigation', async () => {
        // Navigate through steps and verify next-action consistency
        const steps = [0, 1, 2];

        for (const stepIndex of steps) {
          callIframeFunction('setState', 'currentStep', stepIndex);
          setIframeGlobal('currentStep', stepIndex);
          callIframeFunction('renderStepContent');

          await wait(300);

          // Trigger next-action update
          const highlightFunc = getIframeGlobal('highlightNextAction');
          if (typeof highlightFunc === 'function') {
            highlightFunc();
            await wait(200);
          }

          // Should have 0 or 1 element with next-action
          const nextActionElements = getIframeElements('.next-action');
          expect(nextActionElements.length <= 1).toBeTruthy();
        }
      });

      it('should follow complete next-action flow for Step 1 (Connect Accounts)', async () => {
        // Test the complete flow as documented in NEXT_ACTION_FLOW.md

        // 1.1 Initial State - Connect Twilio button should have next-action
        callIframeFunction('setState', 'currentStep', 0);
        callIframeFunction('setState', 'twilioConnected', false);
        callIframeFunction('setState', 'openaiConnected', false);
        setIframeGlobal('currentStep', 0);
        setIframeGlobal('twilioConnected', false);
        setIframeGlobal('openaiConnected', false);

        callIframeFunction('renderStepContent');
        await wait(300);

        // Verify only 0-1 elements have next-action
        let result = verifySingleNextAction();
        expect(result.pass).toBeTruthy();

        // 1.2 After Twilio Connected - OpenAI button should have next-action
        callIframeFunction('setState', 'twilioConnected', true);
        setIframeGlobal('twilioConnected', true);

        const checkStep1 = getIframeGlobal('checkStep1Complete');
        if (typeof checkStep1 === 'function') {
          await checkStep1();
          await wait(700); // Wait for setTimeout

          result = verifySingleNextAction('[onclick*="connectOpenAI"]');
          expect(result.pass).toBeTruthy();
        }

        // 1.3 After Both Connected - Next button should have next-action
        callIframeFunction('setState', 'openaiConnected', true);
        setIframeGlobal('openaiConnected', true);

        if (typeof checkStep1 === 'function') {
          await checkStep1();
          await wait(300);

          result = verifySingleNextAction('#nextBtn1');
          expect(result.pass).toBeTruthy();
        }
      });

      it('should follow complete next-action flow for Step 4 (Deploy Basic Handler)', async () => {
        // Test the complete flow: Validate ‚Üí Commit ‚Üí Test ‚Üí Next

        // 4.1 Initial State - Validate button should have next-action
        callIframeFunction('setState', 'currentStep', 3);
        callIframeFunction('setState', 'step4CodeValidated', false);
        callIframeFunction('setState', 'step4Deployed', false);
        callIframeFunction('setState', 'callDirection', 'outbound');
        setIframeGlobal('currentStep', 3);
        setIframeGlobal('callDirection', 'outbound');

        callIframeFunction('renderStepContent');
        await wait(300);

        callIframeFunction('restoreButtonStates');
        await wait(200);

        let result = verifySingleNextAction('[onclick="validateCode4()"]');
        expect(result.pass).toBeTruthy();

        // 4.2 After Validation - Commit button should have next-action
        const code4 = getIframeElement('#code4');
        if (code4) {
          code4.value = `exports.handler = function(context, event, callback) {
            const twilio = require('twilio');
            const twiml = new twilio.twiml.VoiceResponse();
            twiml.say('Hello').gather({ numDigits: 1 }).say('Press 1');
            callback(null, twiml);
          };`;

          callIframeFunction('validateCode4');
          await wait(300);

          result = verifySingleNextAction('#commitStep4Btn');
          expect(result.pass).toBeTruthy();
        }

        // Note: Full commit ‚Üí test ‚Üí next flow would require mocking API calls
        // which is beyond the scope of this test, but the pattern is validated
      });

      it('should NOT have static next-action classes in HTML templates', async () => {
        // This test ensures we removed all hardcoded next-action classes

        // Step through all steps and check button HTML
        const steps = [0, 1, 2, 3, 4, 5, 6, 7];

        for (const stepIndex of steps) {
          callIframeFunction('setState', 'currentStep', stepIndex);
          setIframeGlobal('currentStep', stepIndex);
          callIframeFunction('renderStepContent');

          await wait(300);

          // Get all buttons
          const buttons = getIframeElements('button');

          // Count buttons that have next-action in their initial class attribute
          // (This would indicate a static class in the template)
          let staticNextActionCount = 0;
          buttons.forEach(btn => {
            // Get the class attribute as string to check if it was in the HTML
            const classAttr = btn.getAttribute('class') || '';
            // If next-action appears in multiple buttons, that's a sign of static classes
            if (classAttr.includes('next-action')) {
              staticNextActionCount++;
            }
          });

          // Should have 0 or 1 buttons with next-action
          // (1 is OK if it was dynamically added, >1 suggests static classes)
          expect(staticNextActionCount <= 1).toBeTruthy();
        }
      });

    }));

    // Test Suite 8: UI Responsiveness
    testSuites.push(describe('UI Responsiveness', () => {

      it('should have responsive container', async () => {
        const container = getIframeElement('.container, .step-container');
        if (container) {
          const computedStyle = getIframeWindow().getComputedStyle(container);
          expect(computedStyle.maxWidth).toBeTruthy();
        }
      });

      it('should render all progress steps', async () => {
        const steps = getIframeGlobal('steps');
        const progressSteps = getIframeElements('.step-item');

        if (steps && progressSteps) {
          expect(progressSteps.length).toBe(steps.length);
        }
      });

    }));

    // =========================================================================
    // TEST RUNNER
    // =========================================================================

    async function runAllTests() {
      const startTime = Date.now();
      testResults = [];

      const resultsDiv = document.getElementById('test-results');
      resultsDiv.innerHTML = '';

      let totalTests = 0;
      let passedTests = 0;
      let failedTests = 0;

      // Ensure iframe is loaded
      await waitForIframeLoad();
      await wait(2000); // Give time for initialization

      // Wait for key globals to be defined
      let retries = 0;
      while (retries < 10) {
        const steps = getIframeGlobal('steps');
        const setState = getIframeGlobal('setState');
        if (steps && steps.length > 0 && typeof setState === 'function') {
          break;
        }
        await wait(500);
        retries++;
      }

      // Update test variables from iframe
      try {
        const updateFunc = getIframeGlobal('updateTestVariables');
        if (typeof updateFunc === 'function') {
          updateFunc();
        }
      } catch (e) {
        console.warn('Could not update test variables:', e);
      }

      for (const suite of testSuites) {
        const suiteDiv = document.createElement('div');
        suiteDiv.className = 'test-suite';
        suiteDiv.innerHTML = `<h2>${suite.name}</h2>`;
        resultsDiv.appendChild(suiteDiv);

        for (const test of suite.tests) {
          totalTests++;

          const testDiv = document.createElement('div');
          testDiv.className = 'test-case running';
          testDiv.innerHTML = `
            <div class="test-name">${test.name}</div>
            <div class="test-result">Running...</div>
          `;
          suiteDiv.appendChild(testDiv);

          try {
            await test.fn();
            testDiv.className = 'test-case pass';
            testDiv.querySelector('.test-result').textContent = '‚úÖ PASS';
            passedTests++;
            test.status = 'pass';
            test.suite = suite.name;
          } catch (error) {
            testDiv.className = 'test-case fail';
            testDiv.querySelector('.test-result').innerHTML = `
              ‚ùå FAIL
              <div class="test-error">${error.message}</div>
            `;
            failedTests++;
            test.status = 'fail';
            test.error = error.message;
            test.suite = suite.name;
          }

          testResults.push(test);
        }
      }

      const endTime = Date.now();
      const elapsed = endTime - startTime;

      document.getElementById('total-tests').textContent = totalTests;
      document.getElementById('passed-tests').textContent = passedTests;
      document.getElementById('failed-tests').textContent = failedTests;
      document.getElementById('time-elapsed').textContent = `${elapsed}ms`;

      // Update summary color
      const summaryDiv = document.getElementById('summary');
      if (failedTests === 0) {
        summaryDiv.style.background = '#28a745';
      } else {
        summaryDiv.style.background = '#dc3545';
      }
    }

    // Generate text summary for copying/pasting
    function showTextSummary() {
      if (testResults.length === 0) {
        alert('Please run tests first!');
        return;
      }

      const totalTests = testResults.length;
      const passedTests = testResults.filter(t => t.status === 'pass').length;
      const failedTests = testResults.filter(t => t.status === 'fail').length;

      let summary = 'üß™ UI INTERACTION TEST RESULTS\n';
      summary += '='.repeat(60) + '\n\n';
      summary += `Total Tests:  ${totalTests}\n`;
      summary += `Passed:       ${passedTests} ‚úÖ\n`;
      summary += `Failed:       ${failedTests} ‚ùå\n\n`;

      if (failedTests > 0) {
        summary += '‚ùå FAILED TESTS:\n';
        summary += '-'.repeat(60) + '\n\n';

        const suiteMap = {};
        testResults.forEach(test => {
          if (test.status === 'fail') {
            if (!suiteMap[test.suite]) {
              suiteMap[test.suite] = [];
            }
            suiteMap[test.suite].push(test);
          }
        });

        Object.keys(suiteMap).forEach(suiteName => {
          summary += `${suiteName}:\n`;
          suiteMap[suiteName].forEach(test => {
            summary += `  ‚ùå ${test.name}\n`;
            summary += `     ${test.error}\n\n`;
          });
        });
      } else {
        summary += '‚úÖ ALL TESTS PASSED!\n';
      }

      summary += '='.repeat(60);

      // Show in a textarea modal for easy copying
      const modal = document.createElement('div');
      modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 9999;';

      const content = document.createElement('div');
      content.style.cssText = 'background: white; padding: 30px; border-radius: 8px; max-width: 800px; width: 90%;';

      const title = document.createElement('h2');
      title.textContent = 'Test Results Summary';
      title.style.marginTop = '0';

      const textarea = document.createElement('textarea');
      textarea.value = summary;
      textarea.style.cssText = 'width: 100%; height: 400px; font-family: monospace; font-size: 0.9em; padding: 15px; border: 1px solid #ccc; border-radius: 4px; margin: 15px 0;';
      textarea.readOnly = true;

      const copyBtn = document.createElement('button');
      copyBtn.textContent = 'üìã Copy to Clipboard';
      copyBtn.style.cssText = 'background: #0066cc; color: white; border: none; padding: 12px 24px; font-size: 1em; border-radius: 4px; cursor: pointer; margin-right: 10px;';
      copyBtn.onclick = () => {
        textarea.select();
        document.execCommand('copy');
        copyBtn.textContent = '‚úÖ Copied!';
        setTimeout(() => { copyBtn.textContent = 'üìã Copy to Clipboard'; }, 2000);
      };

      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.style.cssText = 'background: #6c757d; color: white; border: none; padding: 12px 24px; font-size: 1em; border-radius: 4px; cursor: pointer;';
      closeBtn.onclick = () => document.body.removeChild(modal);

      content.appendChild(title);
      content.appendChild(textarea);
      content.appendChild(copyBtn);
      content.appendChild(closeBtn);
      modal.appendChild(content);
      document.body.appendChild(modal);

      textarea.select();
    }

    // Auto-run tests on page load
    window.addEventListener('load', () => {
      setTimeout(() => runAllTests(), 2000);
    });
  </script>
</body>
</html>
